"""
Module for preprocessing tasks such as downloading videos, creating folders, and more.
"""

from pathlib import Path
import subprocess
import time
import json
#import cv2
import yt_dlp
import ffmpeg


def download_youtube_video(
    url: str, output_name: str = None, output_folder: str = "./data/raw"
):
    """
    Download YouTube video as MP4.

    :param url: YouTube video URL
    :param output_name: filename without extension (default: 'match_<title>')
    :param output_folder: folder to save video (default: ./data/raw)
    :raises ValueError: on invalid URL or download error
    """
    output_folder = Path(output_folder)

    if not output_folder.exists() or not output_folder.is_dir():
        raise ValueError("The output folder does not exist")

    try:
        with yt_dlp.YoutubeDL({"quiet": True}) as ydl:
            info = ydl.extract_info(url, download=False)
            title = info.get("title", "video")
    except yt_dlp.DownloadError as e:
        raise ValueError(f"Invalid YouTube URL or download error: {url}") from e
    except Exception as e:
        raise ValueError(f"Error extracting video information: {e}") from e

    if output_name is None:
        safe_title = "".join(
            c for c in title if c.isalnum() or c in (" ", "_", "-")
        ).rstrip()
        output_name = f"match_{safe_title}"
    # @generated "[Partial]" ChatGPT o4: [Had some problem with download, so I prompted and this settings works]
    ydl_opts = {
        "outtmpl": str(output_folder / f"{output_name}.%(ext)s"),
        "format": "bv*+ba/best",
        "merge_output_format": "mp4",
        "user_agent": "com.google.android.youtube/17.10.35",
        "quiet": False,
        "noplaylist": True,
        "ignoreerrors": True,
        "concurrent_fragment_downloads": 5,
    }

    with yt_dlp.YoutubeDL(ydl_opts) as ydl:
        try:
            ydl.download([url])
        except Exception as e:
            raise ValueError(f"Error downloading video: {e}") from e

    print(f"Download complete: {output_name} in {output_folder}")


def cut_video(
    start_time: int, end_time: int, input_file: str = None, output_file: str = None
):
    """
    Cut video segment without re-encoding.

    :param start_time: start time in seconds
    :param end_time: end time in seconds
    :param input_file: input video path (default: newest in ./data/raw)
    :param output_file: output video path (default: autogenerated in ./data/cut)
    :return: Path to cut video file
    :raises FileNotFoundError: if input not found
    :raises ValueError: if end_time <= start_time
    """
    if input_file is None:
        raw_folder = Path("./data/raw")
        video_files = list(raw_folder.glob("*.mp4"))
        if not video_files:
            raise FileNotFoundError("No .mp4 files found in ./data/raw/")
        input_file = min(video_files, key=lambda f: f.stat().st_mtime)
        print(f"Auto-selected latest video: {input_file}")
    else:
        input_file = Path(input_file)

    if not input_file.exists():
        raise FileNotFoundError(f"Input video not found: {input_file}")

    duration = end_time - start_time
    if duration <= 0:
        raise ValueError("End time must be greater than start time")

    output_folder = Path("./data/cut")
    output_folder.mkdir(parents=True, exist_ok=True)

    # @generated "[ALL]" ChatGPT o4: [It didn’t work initially, so I asked for help and this setting worked, so I kept it]
    if output_file is None:
        safe_title = "".join(
            c for c in input_file.stem if c.isalnum() or c in (" ", "_", "-")
        ).rstrip()
        output_file = output_folder / f"cut_{safe_title}_{start_time}_{end_time}.mp4"
    else:
        output_file = Path(output_file)

    (
        ffmpeg.input(str(input_file), ss=start_time)
        .output(str(output_file), t=duration, c="copy")
        .overwrite_output()
        .run(quiet=True)
    )

    print(f"Video cut: {output_file}")
    return output_file


# Function used to create frames for data labeling

# def extract_frames(input_file=None, output_folder="./data/frames", frame_interval=5):
#     output_folder = Path(output_folder)
#
#     if input_file is None:
#         cut_folder = Path("./data/cut")
#         video_files = list(cut_folder.glob("*.mp4"))
#         if not video_files:
#             raise FileNotFoundError("No .mp4 files found in ./data/cut/")
#         input_file = max(video_files, key=lambda f: f.stat().st_mtime)
#         print(f"Auto-selected latest video: {input_file}")
#     else:
#         input_file = Path(input_file)
#
#     if not input_file.exists():
#         raise FileNotFoundError(f"Input video not found: {input_file}")
#
#     output_folder.mkdir(parents=True, exist_ok=True)
#
#     existing_frames = list(output_folder.glob("frame_*.jpg"))
#     if existing_frames:
#         existing_numbers = [int(f.stem.split("_")[1]) for f in existing_frames]
#         start_count = max(existing_numbers) + 1
#     else:
#         start_count = 0
#
#     cap = cv2.VideoCapture(str(input_file))
#
#     frame_count = 0
#     saved_count = start_count
#
#     while cap.isOpened():
#         ret, frame = cap.read()
#         if not ret:
#             break
#         if frame_count % frame_interval == 0:
#             output_path = output_folder / f"frame_{saved_count:04d}.jpg"
#             cv2.imwrite(str(output_path), frame)
#             saved_count += 1
#         frame_count += 1
#
#     cap.release()
#     print(f"Saved up to frame_{saved_count - 1:04d}.jpg")

# @generated "[ALL]" ChatGPT o4: [I encountered an error with Streamlit, so I prompted it for help, and it provided this solution—which works now]
def reencode_video(input_path, output_path):
    """
    Re-encode video to H264 (fixes compatibility).

    :param input_path: input video path
    :param output_path: output video path
    """
    input_path = Path(input_path)
    output_path = Path(output_path)
    cmd = [
        "ffmpeg",
        "-y",
        "-i",
        input_path,
        "-vcodec",
        "libx264",
        "-crf",
        "23",
        "-preset",
        "veryfast",
        output_path,
    ]
    subprocess.run(
        cmd, stdout=subprocess.DEVNULL, stderr=subprocess.DEVNULL, check=True
    )


def make_tournament_folder(url):
    """
    Create tournament folder structure based on YouTube video metadata.

    :param url: YouTube video URL
    :return: (base Path, video title)
    """
    try:
        # @generated "[ALL]" ChatGPT o4: [It didn’t work initially, so I asked for help and this setting worked, so I kept it]
        result = subprocess.run(
            ["yt-dlp", "-j", url], capture_output=True, text=True, check=True
        )
        info = json.loads(result.stdout)
        title = info.get("title", "Unknown Title")
        vid = info.get("id", str(int(time.time())))
    except subprocess.CalledProcessError as e:
        print(f"[yt-dlp error] Command failed: {e}")
        title = "Unknown Title"
        vid = str(int(time.time()))
    except json.JSONDecodeError as e:
        print(f"[JSON error] {e}")
        title = "Unknown Title"
        vid = str(int(time.time()))

    base = Path("tournaments") / vid
    (base / "raw").mkdir(parents=True, exist_ok=True)
    (base / "cuts").mkdir(exist_ok=True)
    (base / "analysis").mkdir(exist_ok=True)

    return base, title
